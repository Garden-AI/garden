from pathlib import Path
from typing import Optional, Union
from dataclasses import dataclass, asdict, fields
import typer
import yaml
import pickle
import os

import ipywidgets as widgets  # type: ignore
from IPython.display import display

import nbformat

from nbformat.notebooknode import NotebookNode  # type: ignore


NOTEBOOK_DISPLAY_METADATA_CELL = (
    "# This cell is auto-generated by Garden. Don't delete it. Do keep it as the first cell.\n"
    "# You can use this widget to edit your notebooks metadata.\n"
    "# That way the next time you run this notebook Garden can start it with the same libraries.\n"
    "# Changes made using the metadata editor widget will save when the notebook is saved. \n\n"
    "from garden_ai.notebook_metadata import display_metadata_widget\n"
    "display_metadata_widget()"
)

METADATA_CELL_TAG = "garden_display_metadata_cell"


@dataclass
class RequirementsData:
    file_format: str
    contents: Union[dict, list]

    def as_dict(self):
        return asdict(self)


@dataclass
class NotebookMetadata:
    global_notebook_doi: Optional[str]
    notebook_image_name: Optional[str]
    notebook_image_uri: Optional[str]
    notebook_requirements: Optional[RequirementsData]

    def as_dict(self):
        return asdict(self)


def add_notebook_metadata(
    notebook_path: Path,
):
    """
    Adds metadata editor widget cell to top of the notebook if missing
    Adds empty `garden_metadata` dict to the notebook's metadata if missing
    """

    ntbk = _read_notebook(notebook_path)

    # Find cell with 'garden_display_metadata_cell' tag
    found_cell = False
    for cell in ntbk.cells:
        cell_tags = cell.get("metadata", {}).get("tags", [])
        if METADATA_CELL_TAG in cell_tags:
            found_cell = True

    # If metadata widget cell does not exist, add to top of notebook
    if not found_cell:
        new_cell = nbformat.v4.new_code_cell(NOTEBOOK_DISPLAY_METADATA_CELL)
        new_cell["metadata"] = {
            "tags": [METADATA_CELL_TAG],
        }
        del new_cell["id"]
        ntbk.cells.insert(0, new_cell)

    # Add empty garden_metadata dict to notebooks metadata if missing
    if "garden_metadata" not in ntbk["metadata"]:
        ntbk["metadata"]["garden_metadata"] = {}
    # If some of the fields are set, dont want to write over them
    for field in fields(NotebookMetadata):
        if field.name not in ntbk["metadata"]["garden_metadata"]:
            ntbk["metadata"]["garden_metadata"][field.name] = None

    # Write updated notebook data to file
    nbformat.write(ntbk, notebook_path, version=nbformat.NO_CONVERT)


def get_notebook_metadata(notebook_path: Path) -> NotebookMetadata:
    ntbk = _read_notebook(notebook_path)

    # Return empty notebook metadata dict if was unable to find cell source
    if "garden_metadata" not in ntbk["metadata"]:
        typer.echo("Unable to find garden metadata.")
        return NotebookMetadata(None, None, None, None)

    try:
        return NotebookMetadata(
            ntbk["metadata"]["garden_metadata"]["global_notebook_doi"],
            ntbk["metadata"]["garden_metadata"]["notebook_image_name"],
            ntbk["metadata"]["garden_metadata"]["notebook_image_uri"],
            RequirementsData(
                **ntbk["metadata"]["garden_metadata"]["notebook_requirements"]
            ),
        )
    except Exception:
        typer.echo("Unable to parse garden metadata cell.")
        return NotebookMetadata(None, None, None, None)


def set_notebook_metadata(
    notebook_path: Path,
    notebook_global_doi: Optional[str],
    base_image_name: Optional[str],
    base_image_uri: str,
    requirements_data: Optional[RequirementsData],
):
    ntbk = _read_notebook(notebook_path)

    ntbk["metadata"]["garden_metadata"] = NotebookMetadata(
        notebook_global_doi, base_image_name, base_image_uri, requirements_data
    ).as_dict()

    # Write updated notebook data to file
    nbformat.write(ntbk, notebook_path, version=nbformat.NO_CONVERT)


def read_requirements_data(requirements_path: Path) -> Optional[RequirementsData]:
    # For txt requirements files, contents is list of lines, format is pip
    if requirements_path.suffix in {".txt"}:
        file_format = "pip"
        with open(requirements_path, "r") as req_file:
            # read lines into list and strip any newlines
            file_contents = [line.replace("\n", "") for line in req_file.readlines()]
            req_file.close()
        return RequirementsData(file_format, file_contents)
    # For yaml requirements files, contents is safe_load dict of yaml file, format is conda
    elif requirements_path.suffix in {".yml", ".yaml"}:
        file_format = "conda"
        with open(requirements_path, "r") as req_file:
            file_contents = yaml.safe_load(req_file)
            req_file.close()
        return RequirementsData(file_format, file_contents)
    else:
        typer.echo("Invalid requirements file format.")
        return None


def save_requirements_data(
    requirements_dir_path: Path, requirements_data: RequirementsData
) -> Optional[Path]:
    # Save requirements_data to requirements file in either pip or conda format
    # Returns path to new requirements file or None if was unable to write.
    file_format = requirements_data.file_format
    contents = requirements_data.contents

    if file_format == "pip":
        # requirements file is txt
        requirements_path = requirements_dir_path / "requirements.txt"
        with open(requirements_path, "w") as req_file:
            # contents is list of requirements
            file_contents = ""
            for line in contents:
                file_contents += f"{line}\n"
            req_file.write(file_contents)
        return requirements_path

    elif file_format == "conda":
        # requirements file is yml
        requirements_path = requirements_dir_path / "requirements.yml"
        with open(requirements_path, "w") as req_file:
            # contents is dict of yaml requirements
            yaml.dump(contents, req_file, allow_unicode=True)
        return requirements_path
    else:
        typer.echo(
            f"Invalid format for requirements data, must be either pip or conda, got {file_format}. Ignoring requirements."
        )
        return None


def display_metadata_widget():
    """
    Displays the metadata editor widget
    When one of the widgets fields is changed, pickles and saves the updated NotebookMetadata.
    When the notebook is saved, the post_save_hook in custom_jupyter_config will
    go and look for the pickled NotebookMetadata and save it to the notebooks metadata.
    """

    # NOTEBOOK_PATH env var set in start_container_with_notebook
    notebook_path = os.environ["NOTEBOOK_PATH"]
    nb_meta = get_notebook_metadata(notebook_path)

    output = widgets.Output()

    # Global DOI widget
    doi_widget = widgets.Textarea(
        value=nb_meta.global_notebook_doi,
        placeholder="Global DOI",
        continuous_update=False,
        disabled=False,
    )

    def doi_observer(change):
        with output:
            nonlocal nb_meta
            nb_meta.global_notebook_doi = change.new.strip()
            if nb_meta.global_notebook_doi == "":
                nb_meta.global_notebook_doi = None
            _pickle_metadata(nb_meta)

    doi_widget.observe(doi_observer, "value")

    # Base image name widget
    base_image_widget = widgets.Textarea(
        value=nb_meta.notebook_image_name,
        placeholder="Base image name",
        continuous_update=False,
        disabled=False,
    )

    def base_image_observer(change):
        with output:
            nonlocal nb_meta
            nb_meta.notebook_image_name = change.new.strip()
            if nb_meta.notebook_image_name == "":
                nb_meta.notebook_image_name = None
            _pickle_metadata(nb_meta)

    base_image_widget.observe(base_image_observer, "value")

    # Requirements widget
    req_widget = None
    if nb_meta.notebook_requirements.file_format == "pip":
        reqs_string = "\n".join([req for req in nb_meta.notebook_requirements.contents])
        req_widget = widgets.Textarea(
            value=reqs_string,
            placeholder="Requirements",
            layout=widgets.Layout(width="100%", height="80px"),
            continuous_update=False,
            disabled=False,
        )
    elif nb_meta.notebook_requirements.file_format == "conda":
        req_widget = widgets.Textarea(
            value=yaml.safe_dump(nb_meta.notebook_requirements.contents),
            placeholder="Requirements",
            layout=widgets.Layout(width="100%", height="300px"),
            continuous_update=False,
            disabled=False,
        )

    def reqs_observer(change):
        with output:
            nonlocal nb_meta
            if nb_meta.notebook_requirements.file_format == "pip":
                nb_meta.notebook_requirements.contents = change.new.split("\n")

                if "" in nb_meta.notebook_requirements.contents:
                    nb_meta.notebook_requirements.contents.remove("")
                if nb_meta.notebook_requirements.contents == "":
                    nb_meta.notebook_requirements.contents = None
                _pickle_metadata(nb_meta)
            if nb_meta.notebook_requirements.file_format == "conda":
                nb_meta.notebook_requirements.contents = yaml.safe_load(change.new)
                _pickle_metadata(nb_meta)

    req_widget.observe(reqs_observer, "value")

    # Requirements format widget
    req_format_options = ["pip", "conda"]
    req_format_widget = widgets.SelectMultiple(
        options=req_format_options,
        value=[nb_meta.notebook_requirements.file_format],
        rows=len(req_format_options),
        disabled=False,
    )

    def reqs_format_observer(change):
        with output:
            nonlocal nb_meta
            nb_meta.notebook_requirements.file_format = change.new
            _pickle_metadata(nb_meta)

    req_format_widget.observe(reqs_format_observer, "value")

    req_widget_tabs = widgets.Tab(
        children=[req_widget, req_format_widget], titles=("Requirements", "Format")
    )
    metadata_widget = widgets.Accordion(
        children=[doi_widget, base_image_widget, req_widget_tabs],
        titles=("Global DOI", "Base Image", "Requirements"),
    )

    display(metadata_widget, output)


def _pickle_metadata(nb_meta: NotebookMetadata):
    with open("./notebook_metadata.pkl", "wb") as file:
        pickle.dump(nb_meta, file, protocol=pickle.HIGHEST_PROTOCOL)


def _read_notebook(notebook_path: Path) -> NotebookNode:
    # Read notebook contents with nbformat
    try:
        ntbk = nbformat.read(notebook_path, as_version=4)
        return ntbk
    except ValueError:
        typer.echo(f"Unable to parse notebook: {notebook_path}")
        raise typer.Exit(1)
